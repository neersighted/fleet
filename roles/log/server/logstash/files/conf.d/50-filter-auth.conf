filter {
  if [type] == "auth" {
    grok {
      match => [ "message", "%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:auth_host} %{DATA:auth_source}(\[%{POSINT}\])?: %{GREEDYDATA:message}" ]
      overwrite => [ "message" ]
    }

    grok {
      match => [ "message", "Accepted %{DATA:auth_method} for %{USERNAME:auth_user} from %{IPORHOST:auth_ip} port %{POSINT:auth_port} ssh2(: %{GREEDYDATA:auth_key})?" ]
      add_field => { "auth_event" => "ssh" }
    }
    grok {
      match => [ "message", "Received disconnect from %{IP:auth_ip}" ]
      add_field => { "auth_event" => "ssh_disconnect" }
    }
    grok {
      match => [ "message", "Failed %{DATA:auth_type} for %{USERNAME:auth_user} from %{IPORHOST:auth_ip} port %{POSINT:auth_port}( ssh2(: %{GREEDYDATA:auth_key})?)?" ]
      add_field => { "auth_event" => "ssh_fail" }
    }
    grok {
      match => [ "message", "Invalid user %{USERNAME:auth_user} from %{IP:auth_ip}" ]
      add_field => { "auth_event" => "ssh_invalid" }
    }

    grok {
      match => [
        "message", "%{USERNAME:auth_user} : TTY=%{TTY} ; PWD=%{UNIXPATH} ; USER=%{USERNAME:auth_newuser} ; TSID=%{DATA:auth_tsid} ; COMMAND=%{GREEDYDATA:auth_command}",
        "message", "%{USERNAME:auth_user} : TTY=%{TTY} ; PWD=%{UNIXPATH} ; USER=%{USERNAME:auth_newuser} ; COMMAND=%{GREEDYDATA:auth_command}",
        "message", "%{USERNAME:auth_user} : \(command continued\) %{GREEDYDATA:auth_command}"
      ]
      add_field => { "auth_event" => "sudo" }
    }
    grok {
      match => [ "message", "%{USERNAME:auth_user} : %{POSINT} incorrect password attempts ; TTY=%{TTY} ; PWD=%{UNIXPATH} ; USER=%{USERNAME:auth_newuser} ; COMMAND=%{GREEDYDATA:auth_command}" ]
      add_field => { "auth_event" => "sudo_fail" }
    }

    grok {
      match => [ "message", "Successful su for %{USERNAME:auth_newuser} by %{USERNAME:auth_user}" ]
      add_field => { "auth_event" => "su" }
    }
    grok {
      match => [ "message", "FAILED su for %{USERNAME:auth_newuser} by %{USERNAME:auth_user}" ]
      add_field => { "auth_event" => "su_fail" }
    }

    # Useless!
    if [message] =~ /reverse mapping checking getaddrinfo/ {
      drop { }
    }
    # Redundant!
    if [message] =~ /^input_userauth_request: invalid user/ {
      drop { }
    }
    # Redundant!
    if [message] =~ /Connection closed/ {
      drop { }
    }
    # Useless!
    if [message] =~ /^Disconnecting: Change of username or service not allowed/ {
      drop { }
    }
    # Useless!
    if [message] =~ /^Did not receive identification string/ {
      drop { }
    }
    # Useless!
    if [message] =~ /^pam_unix\(sshd:session\): session (opened|closed)/ {
      drop { }
    }

    # Redundant!
    if [message] =~ /^pam_unix\(sudo:auth\): authentication failure/ {
      drop { }
    }
    # Useless!
    if [message] =~ /^pam_unix\(sudo:session\): session (opened|closed)/ {
      drop { }
    }

    # Redundant!
    if [message] =~ /^pam_unix\(su:auth\): authentication failure/ {
      drop { }
    }
    # Useless!
    if [message] =~ /^pam_unix\(su:session\): session (opened|closed)/ {
      drop { }
    }
    # Useless!
    if [message] =~ /^(\+|\-) \/dev/ {
      drop { }
    }

    # Redundant!
    if [message] =~ /^pam_unix\(cron:session\): session (opened|closed)/ {
      drop { }
    }

    # Useless!
    if [message] =~ /^pam_authenticate: Authentication failure/ {
      drop { }
    }


    # If there is no event type, set the default.
    if ![auth_event] {
      mutate {
        add_field => { "auth_event" => "other" }
      }
    }


    geoip {
      source => "auth_ip"
    }

    date {
      match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      remove_field => [ "timestamp" ]
    }
  }
}
